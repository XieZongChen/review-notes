# Vue 相关复习

## 双向绑定

双向绑定是由 DOM Listeners 和 Data Bindings 组成的。
从 View 侧看，ViewModel 中的 DOM Listeners 工具会监测页面上 DOM 元素的变化，如果有变化，则更改 Model 中的数据；
从 Model 侧看，当更新 Model 中的数据时，Data Bindings 工具会更新页面中的 DOM 元素。

## Vue 是如何实现数据双向绑定的

- 实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化
- 实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新
- 实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数
- 实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和订阅者 Watcher 进行统一管理

## Vue 响应式原理

### Object.defineProperty 响应式实现的原理

1. 调用 observer 方法，使用 defineProperty 依次对 data 中的属性实现监听
2. 如果是数组，则重写原生方法，用户修改数据数组后，先触发更新，再触发原生方法
3. 如果是对象，则依次遍历对象属性，并调用 defineReactive 方法
4. defineReactive 方法中，先调用 observer 方法，实现对象的深度监听，然后使用 defineProperty 监听属性

### Object.defineProperty 的缺点

- 复杂对象需要深度监听，一次性监听到底，计算量比较大
- 对于对象的新增/删除属性的操作，无法监听，需要 Vue.$set、Vue.$delete 辅助
- 需要重写数组原生方法实现数组监听。实现原理是，重写数组原生方法，用户修改数据数组后，先触发更新，再触发原生方法

### Proxy 的优势

- Proxy 可以直接监听对象而非属性
- Proxy 可以直接监听数组的变化
- Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的
- Proxy 返回的是一个新对象，可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改
- Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

### vm.$set 的实现原理

如果目标是数组，直接使用数组的 splice 方法触发响应式

如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）

## 虚拟 DOM（virtual DOM）

### 虚拟 DOM 是什么

虚拟 DOM（Virtual DOM）是 Vue 框架中用于高效管理 UI 更新的核心机制，它是一个用 JavaScript 对象表示的轻量级 DOM 树结构，保存了真实 DOM 的层次、属性和子节点等信息。其核心作用是 **减少直接操作真实 DOM 的次数**，通过内存中的比对和计算，最终仅更新必要的真实 DOM 节点。

### 虚拟 DOM 的实现原理

1. ​ 创建虚拟 DOM​
   - 模板编译：Vue 将模板（template）或渲染函数（render）转换为虚拟 DOM 树
   - 渲染函数：通过 createElement 函数生成虚拟节点（VNode）
2. Diff 算法比对
   - 同层比较：Vue 的 Diff 算法仅比较同一层级的节点，避免跨层级遍历
   - Key 优化：通过 key 属性标识列表项，提升节点复用效率
   - 静态节点标记：静态节点（无动态内容）会被标记为 patchFlag: 0，跳过后续比对
3. ​Patch 过程 ​
   - 最小化更新：仅对差异部分（如文本内容、属性变化）进行真实 DOM 操作
   - 批量处理：将多次 DOM 更新合并为单次任务，减少重排和重绘

### 虚拟 DOM 的核心作用

1. ​ 性能优化 ​
   - 减少真实 DOM 操作次数，避免频繁的重排（Reflow）和重绘（Repaint）。
   - 通过批量更新和静态节点优化，提升渲染效率。
2. ​ 简化开发 ​
   - 开发者专注于数据逻辑，无需手动管理 DOM 更新。
   - 支持声明式编程，代码更易维护。
3. ​ 跨平台能力 ​
   - 虚拟 DOM 的抽象层使其可适配非浏览器环境（如 SSR、原生应用开发）

### Vue 3 与 Vue 2 虚拟 DOM 的差异

1. ​ 响应式系统重构 ​
   - ​Vue 2​：基于 Object.defineProperty，无法监听对象属性新增/删除。
   - ​Vue 3​：改用 Proxy，支持更细粒度的依赖追踪和动态属性响应。
2. ​ 虚拟 DOM 重写 ​
   - Vue 2​：使用 Snabbdom 实现，依赖全量 Diff 算法。
   - ​Vue 3​：彻底重写虚拟 DOM，引入以下优化：
     - 静态节点提升：编译阶段提取静态内容，避免运行时比对。
     - ​PatchFlag 标记：标记动态节点类型（如 TEXT、CLASS），加速 Diff 过程。
     - ​Fragments 支持：允许组件返回多个根节点，减少冗余包装。
3. ​ 编译器优化 ​
   - ​ 模板编译：Vue 3 的编译器生成更高效的渲染函数，减少运行时开销。
   - ​Tree-shaking：未使用的代码可被移除，减小打包体积。
4. ​ 多根节点支持 ​
   - ​Vue 2​：组件必须有一个根节点。
   - ​Vue 3​：支持多根节点，提升模板灵活性

### 虚拟 DOM 一定比操作原生 DOM 快吗

虚拟 DOM 最核心的思想是提升开发效率而非提升性能。React 和 Vue 官网也从来都没有说过虚拟 DOM 会比原生操作 DOM 更快。

虚拟 DOM 保证性能下限，在不进行手动优化的情况下，提供过得去的性能。

虚拟 DOM 并不是比原生 DOM 快，更确切的来说，虚拟 DOM 是比操作不当的原生 DOM 快，如果对原生 DOM 的操作得当的话，原生 DOM 的性能一定优于虚拟 DOM。

虚拟 DOM 的优势在于我们更新节点时候。它会检查哪些节点需要更新。尽量复用已有 DOM，减少 DOM 的删除和重新创建。并且这些操作我们是可以通过自己手动操作 javascript 底层 api 实现的。只是我们手动操作会非常耗费我们的时间和精力。这个工作由虚拟 DOM 代劳，会让我们开发更快速便捷。

框架的意义在于为开发者掩盖底层的 DOM 操作，让开发者可以用声明式的方式写出更容易维护的代码，没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。出于可维护性的考虑，框架已经做好了底层原理上的性能优化，开发者在不需要手动优化的情况下，框架依然可以提供过说得去的性能。

在为开发者提供只需要关注数据的前提下。框架本身已经做好了底层原理上的性能优化（包括但不限于,对 DOM 的调用，算法上的优化）已经是高度封装。这样就可以让开发者使用一些简单的较为容易理解的技术去做开发者原本做不到的事情。	
