# 浏览器相关复习

# 复习资料

- [浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html)

## 进程和线程

### 什么是并行处理

**计算机中的并行处理就是同一时刻处理多个任务**，比如我们要计算下面这三个表达式的值，并显示出结果

```javascript
A = 1 + 2
B = 20 / 5
C = 7 * 8
```

在编写代码的时候，我们可以把这个过程拆分为四个任务：
- 任务 1 是计算 A
- 任务 2 是计算 B
- 任务 3 是计算 C
- 任务 4 是显示最后计算的结果

正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。

如果采用多线程，我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。

通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能

![image](https://github.com/XieZongChen/review-notes/assets/46394163/4c26ffc5-784c-45f4-b36a-1d281cf15bf7)

### 线程 VS 进程

**线程是不能单独存在的**，它是由进程来启动和管理的。**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。总的来说，进程和线程之间的关系有以下4个特点：

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃
2. 线程之间共享进程中的数据
   ![image](https://github.com/XieZongChen/review-notes/assets/46394163/5a37d999-c2e2-4dd6-b575-8eb273ac1d38)
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收
4. 进程之间的内容相互隔离，每一个进程只能访问自己占有的数据。一个进程如果崩溃或者挂起，是不会影响到其他进程的。进程之间的数据通信需要使用用于进程间通信（IPC）的机制

## 单进程浏览器

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示

![image](https://github.com/XieZongChen/review-notes/assets/46394163/50863219-0a2f-481d-b15e-4bcad759edea)

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素

## 多进程浏览器

Chrome 经历了多次多进程的调整，目前 Chrome 进程架构如下

![image](https://github.com/XieZongChen/review-notes/assets/46394163/beebbe8d-4f10-46c3-ad7d-b2dd4e849823)

从图中可以看出，Chrome 浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了

经典问题：**仅仅打开了1个页面，为什么有4个进程？** 因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。

## 浏览器的渲染

浏览器的渲染机制非常复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线。

按照渲染的时间顺序，流水线可分为如下几个子阶段：**构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**。

### 构建 DOM 树

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM树。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/57c91086-5993-4756-b949-71b470b0878e)

DOM 是保存在内存中的树状结构，可以通过 JavaScript 来查询或修改其内容。

### 样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成：
1. 把 CSS 转换为浏览器能够理解的结构。
   CSS样式来源主要有：通过 link 引用的外部CSS文件、`<style>` 标记内的 CSS、元素的 style 属性内嵌的CSS。
   浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。
2. 转换样式表中的属性值，使其标准化。
   ![image](https://github.com/XieZongChen/review-notes/assets/46394163/e530d26c-1ddc-48a5-b783-777387364d1e) 
3. 计算出 DOM 树中每个节点的具体样式。
   计算过程中需要遵守 CSS 的继承和层叠两个规则。**继承规则** 保证了部分 CSS 样式属性可以让子节点从自己的父节点中继承，从而减少代码维护成本。**层叠规则** 是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。
   这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

### 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要 **计算出DOM树中可见元素的几何位置**，我们把这个计算过程叫做布局。
   
Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。
1. 创建布局树。为了构建布局树，浏览器大体上完成了下面这些工作
   - 将不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容、包含 dispaly:none 属性的节点
   - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中
2. 布局计算。当有了一棵完整的布局树，就要开始计算布局树节点的坐标位置了。布局的计算过程非常复杂，开头提到的子阶段中分层、绘制、分块、光栅化和合成都属于布局计算，这些子阶段在后续详细讲解。
   在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以 **布局树既是输入内容也是输出内容**，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。
   针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

### 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等。为了更加方便地实现这些效果，渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层：
- 拥有层叠上下文属性的元素会被提升为单独的一层
  ![image](https://github.com/XieZongChen/review-notes/assets/46394163/40ede30a-88cf-46a7-8146-25bcf9a3da4b)
- 需要剪裁（clip）的地方也会被创建为图层。当节点设置的样式大小小于其内容大小时，会发生剪裁。出现这种裁剪情况的时候，渲染引擎会为内容部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。
  
### 图层绘制

渲染引擎实现图层的绘制会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

绘制列表中的指令非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。

### 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做 **视口（viewport）**。

合成线程会将图层划分为图块（tile），这些图块的大小通常是 256 x 256 或者 512 x 512。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。

栅格化是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

GPU 操作是运行在 GPU 进程中的，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/b30382e4-0113-44a8-b7c9-9dd86376f7c5)

### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

### 渲染流水线总结

![image](https://github.com/XieZongChen/review-notes/assets/46394163/39085535-4f0c-4f96-bfe7-304fe6d1033a)

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上

### 重排

![image](https://github.com/XieZongChen/review-notes/assets/46394163/faa5fb0e-a10e-413a-a706-970c4808e018)

通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。

重排需要更新完整的渲染流水线，所以开销也是最大的。

### 重绘

![image](https://github.com/XieZongChen/review-notes/assets/46394163/46c4f119-7b02-4f22-80ac-d5b8f646e1e9)

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。

相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

### 直接合成阶段

如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，这个过程叫做直接合成。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/5cf11e86-93c8-4e47-a8da-2cb8caf0ed15)

在上图中使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。

这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

## JavaScript 的执行顺序

### 变量提升（Hoisting）

所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。

从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面。但这并不准确。**实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中**。

### 执行流程

一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。

#### 1. 编译阶段

![image](https://github.com/XieZongChen/review-notes/assets/46394163/1624fb09-a2a9-41d3-a19b-313fe439c4ab)

输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

执行上下文中存在一个 **变量环境** 的对象（Viriable Environment），该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。

#### 2. 执行阶段

JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。遇到变量、函数时，会去变量环境里找。

## 调用栈

有三种情况下代码执行之前会进行编译并创建执行上下文：
- 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
- 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
- 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。因此搞清楚调用栈要先弄明白函数调用和栈结构。

### 函数调用

函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。下面一段代码

```javascript
var a = 2
function add(){
   var b = 10
   return a + b
}
add()
```

其执行时的完整流程如下：

![image](https://github.com/XieZongChen/review-notes/assets/46394163/547f4e8f-bc67-40fd-8d37-84e3c3be7c68)

当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。也就是说在执行JavaScript时，可能会存在多个执行上下文。

JavaScript 引擎是通过 **栈** 数据结构来管理这些执行上下文的。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/75c688ad-7fa8-4964-9bda-35206445b65b)

### JavaScript 的调用栈

在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称 **调用栈**。

调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

## 块级作用域

JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这是 JavaScript 的一个重要设计缺陷。ECMAScript6（以下简称ES6）已经通过引入块级作用域并配合 let、const 关键字，来避开了这种设计缺陷。
但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。要彻底的理解为什么要有变量提升以及如何解决变量提升带来的问题，需要学习作用域相关概念。

### 作用域

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。
- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 `{}` 都可以被看作是一个块级作用域。

如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

为什么早期的 JavaScript 不设计块级作用域呢？因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计。

### 变量提升所带来的问题

没有块级作用域导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

变量提升带来了两个常见问题：
1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁（比如常见的面试题：for 循环中的 i 的输出结果）

### ES6 是如何解决变量提升带来的缺陷

为了解决变量提升所带来的问题，ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。

这两个关键字是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把代码块中通过 let 或 const 声明的变量存放到变量环境中，这就意味着在代码块中通过 let 和 const 声明的关键字，并不会提升到全函数可见。这种就非常符合我们的编程习惯了：**作用块内声明的变量不影响块外面的变量**。

### JavaScript 是如何支持块级作用域的

由于 JavaScript 是需要向下兼容的，所以支持的难点在于在同一段代码中，ES6 既要支持 var、function 的变量提升特性，又要支持 let、cosnt 的块级作用域。

当编译一个函数的作用域块时，通过 var 声明的变量会全都被存放到变量环境里面，而通过 let、const 声明的变量，会被存放在词法环境（Lexical Environment）的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。

在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量（let、const），进入一个作用域块后，就会把该作用域块内部的变量（let、const）压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。

当执行一个作用域块并需要查找变量时，会沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，将会继续在变量环境中查找。

当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出（闭包除外）。

**变量环境与词法环境的区别**：在执行上下文初创建时，变量环境和词法环境是相同的。但在执行过程中，词法环境可能会改变（如遇到 let、const 和 `{}` 块级作用域）但变量环境不会改变。词法环境主要处理局部变量，变量环境则用来处理全局变量和函数声明等。

块级作用域是通过词法环境的栈结构来实现，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就能同时支持变量提升和块级作用域了。

## 作用域链和闭包

理解作用域链是理解闭包的基础，而闭包在 JavaScript 中几乎无处不在。

### 作用域链

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。

一个函数的 outer 指向哪里是由词法作用域决定的。

### 词法作用域

词法作用域是由代码中函数 **声明的位置** 来决定的作用域，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/ccfe5097-cff0-4de3-85de-3e8cc64f065c)

从上图可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域 —> bar 函数作用域 —> main 函数作用域 —> 全局作用域。

**词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系**

### 练习——块级作用域中的变量查找

在编写代码的时候，如果你使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量，如果你不了解该过程，那就会有很大概率写出不稳定的代码。

分析一下下面代码：

```javascript
function bar() {
    var myName = " 极客世界 "
    let test1 = 100
    if (1) {
        let myName = "Chrome 浏览器 "
        console.log(test)
    }
}
function foo() {
    var myName = " 极客邦 "
    let test = 2
    {
        let test = 3
        bar()
    }
}
var myName = " 极客时间 "
let myAge = 10
let test = 1
foo()
```

ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中。对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，其调用栈的情况如下图所示：

![image](https://github.com/XieZongChen/review-notes/assets/46394163/3633147e-5ec6-49ed-ac38-a7a08fca090b)

现在是执行到 bar 函数的 if 语块之内，需要打印出来变量 test，那么就需要查找到 test 变量的值，其查找过程在图中使用序号 1、2、3、4、5 标记出来了。

首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。

### 闭包

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其定义时的外部函数中声明的变量。

当通过调用一个函数返回一个内部函数后，即使该函数已经执行结束了，但是内部函数引用该函数的变量依然保存在内存中，我们就把这种形式的集合称为闭包。

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

## this

![image](https://github.com/XieZongChen/review-notes/assets/46394163/a3b3b33a-0956-4672-98a6-45aaa892e759)

从图中可以看出，this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。

全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。

函数执行上下文中的 this 在默认情况下调用也是指向 window 对象的，而下面三种情况会改变函数的 this 指向：
- 通过函数的 call、apply、bind 方法设置：this 指向设置的对象
- 通过对象调用方法设置：通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。
- 通过构造函数设置：通过 new 关键字构建的对象，构造函数中的 this 指向新对象本身

在使用 this 时为了避坑，要谨记以下几点：
- 当函数作为对象的方法调用时，函数中的 this 就是该对象
- 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window
- 嵌套函数中的 this 不会继承外层函数的 this 值（要解决此点，可以在外层使用变量保存，然后传递给嵌套函数；或者使用箭头函数）
- 因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this

## HTTP

### HTTP/1.1

#### HTTP/1.1 的新增内容

1. 改进持久连接

HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段。当一个单个页面包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。为了解决这个问题，HTTP/1.1 中增加了持久连接的方法，它的特点是在 **一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持**。

持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。

默认允许同时建立 6 个 TCP 持久连接。

2. 不成熟的 HTTP 管线化

持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的 **队头阻塞问题**。

HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。

FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。

3. 提供虚拟主机的支持

在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。

因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。

4. 对动态生成的内容提供了完美支持

在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如 Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。

HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。

5. 客户端 Cookie、安全机制

HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。

#### HTTP/1.1 的主要问题

HTTP/1.1 的核心问题是其对带宽的利用率却并不理想，很难将带宽用满。

带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。

之所以会出现这个问题，主要是由以下三个原因导致的。

1. TCP 的慢启动

一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为 **慢启动**。

慢启动是 TCP 为了减少网络拥塞的一种策略。之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。

2. 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽

系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会动态减慢发送或者接收的速度。

这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。

3. 队头阻塞问题

HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。

队头阻塞会影响很多东西：在一次多个请求的过程中，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。

### HTTP/2

HTTP/1.1 存在一些问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。

虽然 TCP 有问题，但是我们依然没有换掉 TCP 的能力，所以我们就要想办法去规避 TCP 的慢启动和 TCP 连接之间的竞争问题。基于此，HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。

队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。

#### HTTP/2 多路复用

![image](https://github.com/XieZongChen/review-notes/assets/46394163/17c9c75a-201a-43cc-a655-2aca0d1057f5)

从图中可以看出，HTTP/2 添加了一个二进制分帧层，那我们就结合图来分析下 HTTP/2 的请求和接收过程：
- 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
- 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
- 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
- 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
- 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
- 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求

从上面的流程可以看出，**通过引入二进制分帧层，就实现了 HTTP 的多路复用技术**。

HTTP 是浏览器和服务器通信的语言，在这里虽然 HTTP/2 引入了二进制分帧层，不过 HTTP/2 的语义和 HTTP/1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用 Cookie 来保持登录状态，依然可以使用 Cache 来缓存本地文件，这些都没有变，**发生改变的只是传输方式**。这意味着不需要为 HTTP/2 去重建生态，且 HTTP/2 推广起来会也相对更轻松了

#### HTTP/2 其他特性

基于二进制分帧层，HTTP/2 还附带实现了很多其他功能：

1. 可以设置请求的优先级

浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。

为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。

2. 服务器推送

HTTP/2 还可以直接将数据提前推送到浏览器。当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。

3. 头部压缩

无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，一个 HTTP 的头文件没有多大，压不压缩可能关系不大。但在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。

#### HTTP/2 的主要问题

1. TCP 的队头阻塞

HTTP/2 的多路复用过程如下图：

![image](https://github.com/XieZongChen/review-notes/assets/46394163/0f56160e-1fb0-4989-98c5-d71ac1e0af54)

在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。

这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。

2. TCP 建立连接的延时

网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标。

 HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。
 - 在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。
 - 进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT

综上，在传输数据之前，需要花掉 3～4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30～40 毫秒。但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上了，这种情况下整个握手过程需要 300～400 毫秒，这时用户就能明显地感受到“慢”了。

3. TCP 协议僵化

TCP 协议存在队头阻塞和建立连接延迟等缺点，那是不是可以通过改进 TCP 协议来解决这些问题呢？

非常困难。之所以这样，主要有两个原因：
1. 中间设备的僵化。中间设备有很多种类型，包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。
2. 操作系统。TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。

### HTTP/3

#### QUIC 协议

HTTP/2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。但是这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。

因此，HTTP/3 选择了一个折衷的方法 —— UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为QUIC 协议。HTTP/2 和 HTTP/3 协议栈的比较可以参考下图：

![image](https://github.com/XieZongChen/review-notes/assets/46394163/30076d10-5b7f-47d6-8eea-88353f42dabb)

通过上图可以看出，HTTP/3 中的 QUIC 协议集合了以下几点功能：
- 实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。
- 集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。
- 实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。
  ![image](https://github.com/XieZongChen/review-notes/assets/46394163/24ac8a68-91af-4156-b6aa-bb47574f506a)
- 实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。

#### HTTP/3 的挑战

在技术层面，HTTP/3 是个很完善的协议。不过要将 HTTP/3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面：
1. 从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。
2. 部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。
3. 中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。

## 浏览器安全

### 同源策略

同源策略（Same-origin policy）是网页中最基础、最核心的安全策略。

如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL **同源**。浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为**同源策略**。

同源策略主要表现在 DOM、Web 数据和网络这三个层面：
1. DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。
2. 数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。
3. 网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

### 同源策略下的妥协

安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而这又带来了很多安全问题。

1. 页面中可以嵌入第三方资源

同源策略只限制了不同源的脚本之间的交互，并不阻止一个页面从其他源加载资源。例如可以在一个页面中通过 img、link、script、iframe 等标签，嵌入来自其他源的图像、样式表、脚本、框架、视频等。

这个妥协带来了 XSS 攻击的问题。

2. 跨域资源共享

默认情况下，如果打开 A 页面，在页面中通过 XMLHttpRequest 或者 Fetch 来请求 B 中的资源，这时同源策略会阻止其向 B 发出请求，这样会大大制约我们的生产力。

为了解决这个问题，浏览器引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。

3. 跨文档消息机制

如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信。

浏览器引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。





























