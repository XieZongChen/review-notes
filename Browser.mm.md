# 浏览器相关复习

# 复习资料

- [浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html)

## 进程和线程

### 什么是并行处理

**计算机中的并行处理就是同一时刻处理多个任务**，比如我们要计算下面这三个表达式的值，并显示出结果

```javascript
A = 1 + 2
B = 20 / 5
C = 7 * 8
```

在编写代码的时候，我们可以把这个过程拆分为四个任务：
- 任务 1 是计算 A
- 任务 2 是计算 B
- 任务 3 是计算 C
- 任务 4 是显示最后计算的结果

正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。

如果采用多线程，我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。

通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能

![image](https://github.com/XieZongChen/review-notes/assets/46394163/4c26ffc5-784c-45f4-b36a-1d281cf15bf7)

### 线程 VS 进程

**线程是不能单独存在的**，它是由进程来启动和管理的。**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。总的来说，进程和线程之间的关系有以下4个特点：

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃
2. 线程之间共享进程中的数据
   ![image](https://github.com/XieZongChen/review-notes/assets/46394163/5a37d999-c2e2-4dd6-b575-8eb273ac1d38)
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收
4. 进程之间的内容相互隔离，每一个进程只能访问自己占有的数据。一个进程如果崩溃或者挂起，是不会影响到其他进程的。进程之间的数据通信需要使用用于进程间通信（IPC）的机制

## 单进程浏览器

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示

![image](https://github.com/XieZongChen/review-notes/assets/46394163/50863219-0a2f-481d-b15e-4bcad759edea)

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素

## 多进程浏览器

Chrome 经历了多次多进程的调整，目前 Chrome 进程架构如下

![image](https://github.com/XieZongChen/review-notes/assets/46394163/beebbe8d-4f10-46c3-ad7d-b2dd4e849823)

从图中可以看出，Chrome 浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了

经典问题：**仅仅打开了1个页面，为什么有4个进程？** 因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。

## 浏览器的渲染

浏览器的渲染机制非常复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线。

按照渲染的时间顺序，流水线可分为如下几个子阶段：**构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**。

### 构建 DOM 树

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM树。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/57c91086-5993-4756-b949-71b470b0878e)

DOM 是保存在内存中的树状结构，可以通过 JavaScript 来查询或修改其内容。

### 样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成：
1. 把 CSS 转换为浏览器能够理解的结构。
   CSS样式来源主要有：通过 link 引用的外部CSS文件、`<style>` 标记内的 CSS、元素的 style 属性内嵌的CSS。
   浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。
2. 转换样式表中的属性值，使其标准化。
   ![image](https://github.com/XieZongChen/review-notes/assets/46394163/e530d26c-1ddc-48a5-b783-777387364d1e) 
3. 计算出 DOM 树中每个节点的具体样式。
   计算过程中需要遵守 CSS 的继承和层叠两个规则。**继承规则** 保证了部分 CSS 样式属性可以让子节点从自己的父节点中继承，从而减少代码维护成本。**层叠规则** 是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。
   这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

### 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要 **计算出DOM树中可见元素的几何位置**，我们把这个计算过程叫做布局。
   
Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。
1. 创建布局树。为了构建布局树，浏览器大体上完成了下面这些工作
   - 将不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容、包含 dispaly:none 属性的节点
   - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中
2. 布局计算。当有了一棵完整的布局树，就要开始计算布局树节点的坐标位置了。布局的计算过程非常复杂，开头提到的子阶段中分层、绘制、分块、光栅化和合成都属于布局计算，这些子阶段在后续详细讲解。
   在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以 **布局树既是输入内容也是输出内容**，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。
   针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

### 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等。为了更加方便地实现这些效果，渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层：
- 拥有层叠上下文属性的元素会被提升为单独的一层
  ![image](https://github.com/XieZongChen/review-notes/assets/46394163/40ede30a-88cf-46a7-8146-25bcf9a3da4b)
- 需要剪裁（clip）的地方也会被创建为图层。当节点设置的样式大小小于其内容大小时，会发生剪裁。出现这种裁剪情况的时候，渲染引擎会为内容部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。
  
### 图层绘制

渲染引擎实现图层的绘制会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

绘制列表中的指令非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。

### 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做 **视口（viewport）**。

合成线程会将图层划分为图块（tile），这些图块的大小通常是 256 x 256 或者 512 x 512。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。

栅格化是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

GPU 操作是运行在 GPU 进程中的，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/b30382e4-0113-44a8-b7c9-9dd86376f7c5)

### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

### 渲染流水线总结

![image](https://github.com/XieZongChen/review-notes/assets/46394163/39085535-4f0c-4f96-bfe7-304fe6d1033a)

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上

### 重排

![image](https://github.com/XieZongChen/review-notes/assets/46394163/faa5fb0e-a10e-413a-a706-970c4808e018)

通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。

重排需要更新完整的渲染流水线，所以开销也是最大的。

### 重绘

![image](https://github.com/XieZongChen/review-notes/assets/46394163/46c4f119-7b02-4f22-80ac-d5b8f646e1e9)

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。

相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

### 直接合成阶段

如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，这个过程叫做直接合成。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/5cf11e86-93c8-4e47-a8da-2cb8caf0ed15)

在上图中使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。

这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

## JavaScript 的执行顺序

### 变量提升（Hoisting）

所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。

从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面。但这并不准确。**实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中**。

### 执行流程

一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。

#### 1. 编译阶段

![image](https://github.com/XieZongChen/review-notes/assets/46394163/1624fb09-a2a9-41d3-a19b-313fe439c4ab)

输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

执行上下文中存在一个 **变量环境** 的对象（Viriable Environment），该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。

#### 2. 执行阶段

JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。遇到变量、函数时，会去变量环境里找。

## 调用栈

有三种情况下代码执行之前会进行编译并创建执行上下文：
- 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
- 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
- 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。因此搞清楚调用栈要先弄明白函数调用和栈结构。

### 函数调用

函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。下面一段代码

```javascript
var a = 2
function add(){
   var b = 10
   return a + b
}
add()
```

其执行时的完整流程如下：

![image](https://github.com/XieZongChen/review-notes/assets/46394163/547f4e8f-bc67-40fd-8d37-84e3c3be7c68)

当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。也就是说在执行JavaScript时，可能会存在多个执行上下文。

JavaScript 引擎是通过 **栈** 数据结构来管理这些执行上下文的。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/75c688ad-7fa8-4964-9bda-35206445b65b)

### JavaScript 的调用栈

在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称 **调用栈**。

调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

## 块级作用域

JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这是 JavaScript 的一个重要设计缺陷。ECMAScript6（以下简称ES6）已经通过引入块级作用域并配合 let、const 关键字，来避开了这种设计缺陷。
但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。要彻底的理解为什么要有变量提升以及如何解决变量提升带来的问题，需要学习作用域相关概念。

### 作用域

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。
- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 `{}` 都可以被看作是一个块级作用域。

如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

为什么早期的 JavaScript 不设计块级作用域呢？因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计。

### 变量提升所带来的问题

没有块级作用域导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

变量提升带来了两个常见问题：
1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁（比如常见的面试题：for 循环中的 i 的输出结果）

### ES6 是如何解决变量提升带来的缺陷

为了解决变量提升所带来的问题，ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。

这两个关键字是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把代码块中通过 let 或 const 声明的变量存放到变量环境中，这就意味着在代码块中通过 let 和 const 声明的关键字，并不会提升到全函数可见。这种就非常符合我们的编程习惯了：**作用块内声明的变量不影响块外面的变量**。

### JavaScript 是如何支持块级作用域的

由于 JavaScript 是需要向下兼容的，所以支持的难点在于在同一段代码中，ES6 既要支持 var、function 的变量提升特性，又要支持 let、cosnt 的块级作用域。

当编译一个函数的作用域块时，通过 var 声明的变量会全都被存放到变量环境里面，而通过 let、const 声明的变量，会被存放在词法环境（Lexical Environment）的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。

在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量（let、const），进入一个作用域块后，就会把该作用域块内部的变量（let、const）压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。

当执行一个作用域块并需要查找变量时，会沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，将会继续在变量环境中查找。

当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出（闭包除外）。

**变量环境与词法环境的区别**：在执行上下文初创建时，变量环境和词法环境是相同的。但在执行过程中，词法环境可能会改变（如遇到 let、const 和 `{}` 块级作用域）但变量环境不会改变。词法环境主要处理局部变量，变量环境则用来处理全局变量和函数声明等。

块级作用域是通过词法环境的栈结构来实现，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就能同时支持变量提升和块级作用域了。

## 作用域链和闭包

理解作用域链是理解闭包的基础，而闭包在 JavaScript 中几乎无处不在。

### 作用域链

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。

一个函数的 outer 指向哪里是由词法作用域决定的。

### 词法作用域

词法作用域是由代码中函数 **声明的位置** 来决定的作用域，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/ccfe5097-cff0-4de3-85de-3e8cc64f065c)

从上图可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域 —> bar 函数作用域 —> main 函数作用域 —> 全局作用域。

**词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系**





















