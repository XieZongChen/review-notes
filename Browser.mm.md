# 浏览器相关复习

# 复习资料

- [浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html)

## 进程和线程

### 什么是并行处理

**计算机中的并行处理就是同一时刻处理多个任务**，比如我们要计算下面这三个表达式的值，并显示出结果

```javascript
A = 1 + 2
B = 20 / 5
C = 7 * 8
```

在编写代码的时候，我们可以把这个过程拆分为四个任务：
- 任务 1 是计算 A
- 任务 2 是计算 B
- 任务 3 是计算 C
- 任务 4 是显示最后计算的结果

正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。

如果采用多线程，我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。

通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能

![image](https://github.com/XieZongChen/review-notes/assets/46394163/4c26ffc5-784c-45f4-b36a-1d281cf15bf7)

### 线程 VS 进程

**线程是不能单独存在的**，它是由进程来启动和管理的。**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。总的来说，进程和线程之间的关系有以下4个特点：

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃
2. 线程之间共享进程中的数据
   ![image](https://github.com/XieZongChen/review-notes/assets/46394163/5a37d999-c2e2-4dd6-b575-8eb273ac1d38)
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收
4. 进程之间的内容相互隔离，每一个进程只能访问自己占有的数据。一个进程如果崩溃或者挂起，是不会影响到其他进程的。进程之间的数据通信需要使用用于进程间通信（IPC）的机制

## 单进程浏览器

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示

![image](https://github.com/XieZongChen/review-notes/assets/46394163/50863219-0a2f-481d-b15e-4bcad759edea)

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素

## 多进程浏览器

Chrome 经历了多次多进程的调整，目前 Chrome 进程架构如下

![image](https://github.com/XieZongChen/review-notes/assets/46394163/beebbe8d-4f10-46c3-ad7d-b2dd4e849823)

从图中可以看出，Chrome 浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了

经典问题：**仅仅打开了1个页面，为什么有4个进程？** 因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。

## HTML、CSS 和 JavaScript 是如何变成页面的

浏览器的渲染机制非常复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线。

按照渲染的时间顺序，流水线可分为如下几个子阶段：**构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**。

### 构建 DOM 树

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM树。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/57c91086-5993-4756-b949-71b470b0878e)

DOM 是保存在内存中的树状结构，可以通过 JavaScript 来查询或修改其内容。

### 样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成：
1. 把 CSS 转换为浏览器能够理解的结构。
   CSS样式来源主要有：通过 link 引用的外部CSS文件、`<style>` 标记内的 CSS、元素的 style 属性内嵌的CSS。
   浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。
2. 转换样式表中的属性值，使其标准化。
   ![image](https://github.com/XieZongChen/review-notes/assets/46394163/e530d26c-1ddc-48a5-b783-777387364d1e) 
3. 计算出 DOM 树中每个节点的具体样式。
   计算过程中需要遵守 CSS 的继承和层叠两个规则。**继承规则** 保证了部分 CSS 样式属性可以让子节点从自己的父节点中继承，从而减少代码维护成本。**层叠规则** 是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。
   这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

### 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要 **计算出DOM树中可见元素的几何位置**，我们把这个计算过程叫做布局。
   
Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。
1. 创建布局树。为了构建布局树，浏览器大体上完成了下面这些工作
   - 将不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容、包含 dispaly:none 属性的节点
   - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中
2. 布局计算。当有了一棵完整的布局树，就要开始计算布局树节点的坐标位置了。布局的计算过程非常复杂，开头提到的子阶段中分层、绘制、分块、光栅化和合成都属于布局计算，这些子阶段在后续详细讲解。
   在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以 **布局树既是输入内容也是输出内容**，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。
   针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

### 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等。为了更加方便地实现这些效果，渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层：
- 拥有层叠上下文属性的元素会被提升为单独的一层
  ![image](https://github.com/XieZongChen/review-notes/assets/46394163/40ede30a-88cf-46a7-8146-25bcf9a3da4b)
- 需要剪裁（clip）的地方也会被创建为图层。当节点设置的样式大小小于其内容大小时，会发生剪裁。出现这种裁剪情况的时候，渲染引擎会为内容部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。
  
### 图层绘制

渲染引擎实现图层的绘制会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

绘制列表中的指令非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。

### 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做 **视口（viewport）**。

合成线程会将图层划分为图块（tile），这些图块的大小通常是 256 x 256 或者 512 x 512。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。

栅格化是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

GPU 操作是运行在 GPU 进程中的，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/b30382e4-0113-44a8-b7c9-9dd86376f7c5)

### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

### 渲染流水线总结

![image](https://github.com/XieZongChen/review-notes/assets/46394163/39085535-4f0c-4f96-bfe7-304fe6d1033a)

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上
























