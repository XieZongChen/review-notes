# 浏览器相关复习

# 复习资料

- [浏览器工作原理与实践](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html)

## 进程和线程

### 什么是并行处理

**计算机中的并行处理就是同一时刻处理多个任务**，比如我们要计算下面这三个表达式的值，并显示出结果

```javascript
A = 1 + 2
B = 20 / 5
C = 7 * 8
```

在编写代码的时候，我们可以把这个过程拆分为四个任务：
- 任务 1 是计算 A
- 任务 2 是计算 B
- 任务 3 是计算 C
- 任务 4 是显示最后计算的结果

正常情况下程序可以使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。

如果采用多线程，我们只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。

通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能

![image](https://github.com/XieZongChen/review-notes/assets/46394163/4c26ffc5-784c-45f4-b36a-1d281cf15bf7)

### 线程 VS 进程

**线程是不能单独存在的**，它是由进程来启动和管理的。**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。总的来说，进程和线程之间的关系有以下4个特点：

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃
2. 线程之间共享进程中的数据
   ![image](https://github.com/XieZongChen/review-notes/assets/46394163/5a37d999-c2e2-4dd6-b575-8eb273ac1d38)
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收
4. 进程之间的内容相互隔离，每一个进程只能访问自己占有的数据。一个进程如果崩溃或者挂起，是不会影响到其他进程的。进程之间的数据通信需要使用用于进程间通信（IPC）的机制

## 单进程浏览器

单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。早在2007年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示

![image](https://github.com/XieZongChen/review-notes/assets/46394163/50863219-0a2f-481d-b15e-4bcad759edea)

如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素

## 多进程浏览器

Chrome 经历了多次多进程的调整，目前 Chrome 进程架构如下

![image](https://github.com/XieZongChen/review-notes/assets/46394163/beebbe8d-4f10-46c3-ad7d-b2dd4e849823)

从图中可以看出，Chrome 浏览器包括：1个浏览器（Browser）主进程、1个 GPU 进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU进程。其实，Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome在其多进程架构上也引入了GPU进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响

虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了

经典问题：**仅仅打开了1个页面，为什么有4个进程？** 因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。

## 浏览器的渲染

浏览器的渲染机制非常复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做渲染流水线。

按照渲染的时间顺序，流水线可分为如下几个子阶段：**构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**。

### 构建 DOM 树

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM树。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/57c91086-5993-4756-b949-71b470b0878e)

DOM 是保存在内存中的树状结构，可以通过 JavaScript 来查询或修改其内容。

HTML 解析成 DOM 树的具体过程如下：

![image](https://github.com/XieZongChen/review-notes/assets/46394163/e811dca7-3b9a-4b77-acff-e23d54ff58d6)


### 样式计算

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成：
1. 把 CSS 转换为浏览器能够理解的结构。
   CSS样式来源主要有：通过 link 引用的外部CSS文件、`<style>` 标记内的 CSS、元素的 style 属性内嵌的CSS。
   浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。
2. 转换样式表中的属性值，使其标准化。
   ![image](https://github.com/XieZongChen/review-notes/assets/46394163/e530d26c-1ddc-48a5-b783-777387364d1e) 
3. 计算出 DOM 树中每个节点的具体样式。
   计算过程中需要遵守 CSS 的继承和层叠两个规则。**继承规则** 保证了部分 CSS 样式属性可以让子节点从自己的父节点中继承，从而减少代码维护成本。**层叠规则** 是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。
   这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

### 布局阶段

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要 **计算出DOM树中可见元素的几何位置**，我们把这个计算过程叫做布局。
   
Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。
1. 创建布局树。为了构建布局树，浏览器大体上完成了下面这些工作
   - 将不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容、包含 dispaly:none 属性的节点
   - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中
2. 布局计算。当有了一棵完整的布局树，就要开始计算布局树节点的坐标位置了。布局的计算过程非常复杂，开头提到的子阶段中分层、绘制、分块、光栅化和合成都属于布局计算，这些子阶段在后续详细讲解。
   在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以 **布局树既是输入内容也是输出内容**，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。
   针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

### 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等。为了更加方便地实现这些效果，渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。不管怎样，最终每一个节点都会直接或者间接地从属于一个层。

通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层：
- 拥有层叠上下文属性的元素会被提升为单独的一层
  ![image](https://github.com/XieZongChen/review-notes/assets/46394163/40ede30a-88cf-46a7-8146-25bcf9a3da4b)
- 需要剪裁（clip）的地方也会被创建为图层。当节点设置的样式大小小于其内容大小时，会发生剪裁。出现这种裁剪情况的时候，渲染引擎会为内容部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。
  
### 图层绘制

渲染引擎实现图层的绘制会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

绘制列表中的指令非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。

### 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做 **视口（viewport）**。

合成线程会将图层划分为图块（tile），这些图块的大小通常是 256 x 256 或者 512 x 512。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。

栅格化是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

GPU 操作是运行在 GPU 进程中的，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/b30382e4-0113-44a8-b7c9-9dd86376f7c5)

### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

### 渲染流水线总结

![image](https://github.com/XieZongChen/review-notes/assets/46394163/39085535-4f0c-4f96-bfe7-304fe6d1033a)

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上

### 重排

![image](https://github.com/XieZongChen/review-notes/assets/46394163/faa5fb0e-a10e-413a-a706-970c4808e018)

通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。

重排需要更新完整的渲染流水线，所以开销也是最大的。

### 重绘

![image](https://github.com/XieZongChen/review-notes/assets/46394163/46c4f119-7b02-4f22-80ac-d5b8f646e1e9)

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。

相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

### 直接合成阶段

如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，这个过程叫做直接合成。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/5cf11e86-93c8-4e47-a8da-2cb8caf0ed15)

在上图中使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。

这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

## JavaScript 的执行顺序

### 变量提升（Hoisting）

所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。

从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面。但这并不准确。**实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中**。

### 执行流程

一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。

#### 1. 编译阶段

![image](https://github.com/XieZongChen/review-notes/assets/46394163/1624fb09-a2a9-41d3-a19b-313fe439c4ab)

输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

执行上下文中存在一个 **变量环境** 的对象（Viriable Environment），该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。

#### 2. 执行阶段

JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。遇到变量、函数时，会去变量环境里找。

## 调用栈

有三种情况下代码执行之前会进行编译并创建执行上下文：
- 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
- 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
- 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。因此搞清楚调用栈要先弄明白函数调用和栈结构。

### 函数调用

函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号。下面一段代码

```javascript
var a = 2
function add(){
   var b = 10
   return a + b
}
add()
```

其执行时的完整流程如下：

![image](https://github.com/XieZongChen/review-notes/assets/46394163/547f4e8f-bc67-40fd-8d37-84e3c3be7c68)

当执行到 add 函数的时候，我们就有了两个执行上下文了——全局执行上下文和 add 函数的执行上下文。也就是说在执行JavaScript时，可能会存在多个执行上下文。

JavaScript 引擎是通过 **栈** 数据结构来管理这些执行上下文的。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/75c688ad-7fa8-4964-9bda-35206445b65b)

### JavaScript 的调用栈

在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称 **调用栈**。

调用栈是 JavaScript 引擎追踪函数执行的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

## 块级作用域

JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这是 JavaScript 的一个重要设计缺陷。ECMAScript6（以下简称ES6）已经通过引入块级作用域并配合 let、const 关键字，来避开了这种设计缺陷。
但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。要彻底的理解为什么要有变量提升以及如何解决变量提升带来的问题，需要学习作用域相关概念。

### 作用域

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。
- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个 `{}` 都可以被看作是一个块级作用域。

如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

为什么早期的 JavaScript 不设计块级作用域呢？因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计。

### 变量提升所带来的问题

没有块级作用域导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

变量提升带来了两个常见问题：
1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁（比如常见的面试题：for 循环中的 i 的输出结果）

### ES6 是如何解决变量提升带来的缺陷

为了解决变量提升所带来的问题，ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。

这两个关键字是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把代码块中通过 let 或 const 声明的变量存放到变量环境中，这就意味着在代码块中通过 let 和 const 声明的关键字，并不会提升到全函数可见。这种就非常符合我们的编程习惯了：**作用块内声明的变量不影响块外面的变量**。

### JavaScript 是如何支持块级作用域的

由于 JavaScript 是需要向下兼容的，所以支持的难点在于在同一段代码中，ES6 既要支持 var、function 的变量提升特性，又要支持 let、cosnt 的块级作用域。

当编译一个函数的作用域块时，通过 var 声明的变量会全都被存放到变量环境里面，而通过 let、const 声明的变量，会被存放在词法环境（Lexical Environment）的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。

在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量（let、const），进入一个作用域块后，就会把该作用域块内部的变量（let、const）压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。

当执行一个作用域块并需要查找变量时，会沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，将会继续在变量环境中查找。

当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出（闭包除外）。

**变量环境与词法环境的区别**：在执行上下文初创建时，变量环境和词法环境是相同的。但在执行过程中，词法环境可能会改变（如遇到 let、const 和 `{}` 块级作用域）但变量环境不会改变。词法环境主要处理局部变量，变量环境则用来处理全局变量和函数声明等。

块级作用域是通过词法环境的栈结构来实现，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就能同时支持变量提升和块级作用域了。

## 作用域链和闭包

理解作用域链是理解闭包的基础，而闭包在 JavaScript 中几乎无处不在。

### 作用域链

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。

一个函数的 outer 指向哪里是由词法作用域决定的。

### 词法作用域

词法作用域是由代码中函数 **声明的位置** 来决定的作用域，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/ccfe5097-cff0-4de3-85de-3e8cc64f065c)

从上图可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域 —> bar 函数作用域 —> main 函数作用域 —> 全局作用域。

**词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系**

### 练习——块级作用域中的变量查找

在编写代码的时候，如果你使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量，如果你不了解该过程，那就会有很大概率写出不稳定的代码。

分析一下下面代码：

```javascript
function bar() {
    var myName = " 极客世界 "
    let test1 = 100
    if (1) {
        let myName = "Chrome 浏览器 "
        console.log(test)
    }
}
function foo() {
    var myName = " 极客邦 "
    let test = 2
    {
        let test = 3
        bar()
    }
}
var myName = " 极客时间 "
let myAge = 10
let test = 1
foo()
```

ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中。对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，其调用栈的情况如下图所示：

![image](https://github.com/XieZongChen/review-notes/assets/46394163/3633147e-5ec6-49ed-ac38-a7a08fca090b)

现在是执行到 bar 函数的 if 语块之内，需要打印出来变量 test，那么就需要查找到 test 变量的值，其查找过程在图中使用序号 1、2、3、4、5 标记出来了。

首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。

### 闭包

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其定义时的外部函数中声明的变量。

当通过调用一个函数返回一个内部函数后，即使该函数已经执行结束了，但是内部函数引用该函数的变量依然保存在内存中，我们就把这种形式的集合称为闭包。

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

## this

![image](https://github.com/XieZongChen/review-notes/assets/46394163/a3b3b33a-0956-4672-98a6-45aaa892e759)

从图中可以看出，this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。

全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。

函数执行上下文中的 this 在默认情况下调用也是指向 window 对象的，而下面三种情况会改变函数的 this 指向：
- 通过函数的 call、apply、bind 方法设置：this 指向设置的对象
- 通过对象调用方法设置：通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。
- 通过构造函数设置：通过 new 关键字构建的对象，构造函数中的 this 指向新对象本身

在使用 this 时为了避坑，要谨记以下几点：
- 当函数作为对象的方法调用时，函数中的 this 就是该对象
- 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window
- 嵌套函数中的 this 不会继承外层函数的 this 值（要解决此点，可以在外层使用变量保存，然后传递给嵌套函数；或者使用箭头函数）
- 因为箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this

## 浏览器的帧运行（rIC 和 rAF）

页面是一帧一帧绘制出来的，当 **每秒绘制的帧数（FPS）达到 60 时，页面是流畅的**，小于这个值时，用户会感觉到卡顿。

1s 60帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/7d80a04b-3b8f-42f3-a5f0-46910909545f)

上图可看到，浏览器在一帧内需要完成如下六个步骤的任务：
1. 处理用户的交互
2. JS 解析执行
3. 帧开始。处理窗口尺寸变更，页面滚动等
4. requestAnimationFrame(rAF)
5. 布局
6. 绘制
7. 上面六个步骤完成后没超过 16 ms，说明时间有富余，此时就会执行 requestIdleCallback 里注册的任务。

**requestAnimationFrame 每一帧必定会执行，requestIdleCallback 是捡浏览器空闲来执行任务**

假如浏览器一直处于非常忙碌的状态，requestIdleCallback 注册的任务有可能永远不会执行。此时可通过设置 timeout 来保证执行。超时的情况下如果选择继续执行的话，肯定会出现卡顿的，因为必然会将一帧的时间拉长。

一些低优先级的任务可使用 requestIdleCallback 等浏览器不忙的时候来执行，同时因为时间有限，它所执行的任务应该尽量是 **能够量化，细分的微任务（micro task）**。因为发生在一帧的最后，此时页面布局已经完成，所以 **不建议在 requestIdleCallback 里再操作 DOM**，这样会导致页面再次重绘。**DOM 操作建议在 rAF 中进行**。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。

**Promise 也不建议在 requestIdleCallback 里面进行，因为 Promise 的回调属性 Event loop 中优先级较高的一种微任务，会在 requestIdleCallback 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms**。

在没有 requestAnimationFrame 方法的时候，执行动画，我们可能使用 setTimeout 或 setInterval 来触发视觉变化；但是这种做法的问题是：回调函数执行的时间是不固定的，可能刚好就在末尾，或者直接就不执行了，经常会引起丢帧而导致页面卡顿。问题的原因在于时机，也就是浏览器要知道何时对回调函数进行响应。**setTimeout 或 setInterval 是使用定时器来触发回调函数的，而定时器并无法保证能够准确无误的执行，有许多因素会影响它的运行时机**，比如说：当有同步代码执行时，会先等同步代码执行完毕，异步队列中没有其他任务，才会轮到自己执行。并且，我们知道每一次重新渲染的最佳时间大约是 16.6 ms，**如果定时器的时间间隔过短，就会造成 过度渲染，增加开销；过长又会延迟渲染，使动画不流畅**。

requestAnimationFrame 方法不同与 setTimeout 或 setInterval，它是 **由系统来决定回调函数的执行时机的，会请求浏览器在下一次重新渲染之前执行回调函数。无论设备的刷新率是多少，requestAnimationFrame 的时间间隔都会紧跟屏幕刷新一次所需要的时间**。例如某一设备的刷新率是 75 Hz，那这时的时间间隔就是 13.3 ms（1 秒 / 75 次）。需要注意的是这个方法虽然能够保证 **回调函数在每一帧内只渲染一次**，但是 **如果这一帧有太多任务执行，还是会造成卡顿**。因此它 **只能保证重新渲染的时间间隔最短是屏幕的刷新时间**。

## 浏览器安全

### 同源策略

同源策略（Same-origin policy）是网页中最基础、最核心的安全策略。

如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL **同源**。浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为**同源策略**。

同源策略主要表现在 DOM、Web 数据和网络这三个层面：
1. DOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。
2. 数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。
3. 网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。

### 同源策略下的妥协

安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们就要在这之间做出权衡，出让一些安全性来满足灵活性；而这又带来了很多安全问题。

1. 页面中可以嵌入第三方资源

同源策略只限制了不同源的脚本之间的交互，并不阻止一个页面从其他源加载资源。例如可以在一个页面中通过 img、link、script、iframe 等标签，嵌入来自其他源的图像、样式表、脚本、框架、视频等。

这个妥协带来了 XSS 攻击的问题。

2. 跨域资源共享

默认情况下，如果打开 A 页面，在页面中通过 XMLHttpRequest 或者 Fetch 来请求 B 中的资源，这时同源策略会阻止其向 B 发出请求，这样会大大制约我们的生产力。

为了解决这个问题，浏览器引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。

3. 跨文档消息机制

如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信。

浏览器引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。

## 跨域

协议 + 域名 + 端口号，三者都相同时就是同源，只要有一个不同就是跨域。

为了提升开发速度，方便项目维护，开发通常采用前后端分离的方式，此方式把服务器拆分成三部分：
- Web 服务器：存放静态资源
- 后台服务器：提供业务逻辑和数据分析。
- 图片服务器
三者之间的通讯就出现跨域问题了。

### 跨域解决方案

跨域解决方案总共有 9 种，它们分别为：
1. 通过 JSONP 跨域
2. CORS 跨域资源共享
3. http proxy 代理
4. nginx 反向代理
5. postMessage 跨域
6. Websocket
7. iframe + document.domain
8. iframe + window.name
9. iframe + location.hash

### 具体跨域方案

#### JSONP

script、img、link、iframe 标签可以引入任意域名下的资源，不存在跨域问题。因此我们利用 script 的特点，创建一个带网址的跨域通信。

JSONP 的缺点：只允许处理 get 请求，由于请求的数据都暴露在url中，容易被劫持，安全性很差，所以不推荐使用。

![image](https://github.com/XieZongChen/review-notes/assets/46394163/d1f7d4c3-e054-46d3-8b11-a819565912ef)

```javascript
// 客户端实现 ---------------
// 注意：函数声明放前边
<script>
 function back(res){
  console.log(res) //返回数据
 }
</script>
<script src="http://127.0.0.1:3000/login?user='111'&callback=back"></script>

// 服务端实现（node） ---------------
var querystring = require('querystring');
var http = require('http');
var server = http.createServer();
server.on('request', function(req, res) {
  console.log(req.url.split)
    var params = querystring.parse(req.url.split('?')[1]);
    console.log('params',params)
    var fn = params.callback;
    // jsonp返回设置
    res.writeHead(200, { 'Content-Type': 'text/javascript' });
    res.write(fn + '(' + JSON.stringify(params) + ')');
    res.end();
});
server.listen('3000');

// 执行成功后客户端打印 ---------------
{
 callback: "back"
 user: "'111'"
}
```

#### CORS 跨域资源共享

通过设置响应头处理的，需要后台配合处理。如果只是普通跨域请求，前端无需设置。

特点：客户端发送(ajax fetch)请求，后台设置请求头相关信息，允许哪些源请求数据，需要处理 options 试探性请求。

后台设置 Access-Control-Allow-Origin，如：

```javascript
/* 允许所有域名访问 */
response.setHeader("Access-Control-Allow-Origin","*");

/* 只允许某个域名访问 */
header("Access-Control-Allow-Origin: www.xxx.xom");
```

如果需要带cookie请求，前端也需要设置字段。如：

```javascript
// 前端设置是否带cookie
xhr.withCredentials = true;
```

#### proxy 代理

因为服务器间的数据交互没有跨域限制，所以通过一个中间代理服务器请求目标服务器的数据，也就是前端服务器发送请求到代理服务器，代理服务器再请求目标服务器，将数据返回给前端服务器。

现在常用的三方框架 VUE、React 项目开发环境中跨域解决方案都使用的是代理。如 config.js 代理配置如下：

```javascript
proxy: { //配置跨域
 '/': {
  target: 'http://www.xxxx.com/', //线上
  changOrigin: true, //允许跨域
  pathRewrite: {
   '^/': ''
  }
 },
}
```

















